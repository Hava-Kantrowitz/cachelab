/** * vabowen and hskantrowitz */#include "cachelab.h"#include <stdio.h>#include <stdbool.h>#include <string.h>#include <stdlib.h>/** * Sets up variables and calls the simulation */int main(int argc, char* argv[]){    //so far, this is ONLY for direct mapping!  /*	bool h_flag = false; // determines if print help	bool v_flag = false; // determines if prints specifics	bool done = false; // checks if should stop	int s_index = -1; // the place of the s	int e_index = -1; // the place of the e	int b_index = -1; // the place of the b	int t_index = -1; // the place of the t	int set_index = 0;  // first required argument	int num_lines = 0;  // second required argument	int block_bits = 0; // third required argument	char file_name[100];	FILE* fp;	// checking if help is there	if(argc == 2 && (strcmp(argv[1],"-h") == 0)){		h_flag = true;		done = true;	}	// this is to get all the arguments	if(!done){		// getting the placement of each param		for(int i = 1; i < argc-1; i++){			// if -s then s arg at i+1			if(!(strcmp(argv[i],"-s"))){				s_index = i+1;			}			// same for -E			else if(!(strcmp(argv[i],"-E"))){				e_index = i+1;			}			// same for -b			else if(!(strcmp(argv[i],"-b"))){				b_index = i+1;			}			// same for -t			else if(!(strcmp(argv[i], "-t"))){				t_index = i+1;			}			// if -v then set v flag			else if(!(strcmp(argv[i],"-v"))){				v_flag = true;			}			// if -h then set h flag			else if(!(strcmp(argv[i], "-h"))){				h_flag = true;			}			// if any other option			else if(argv[i][0] == '-'){				done = true;				printf("./csim: invalid option -- '%c'\n",argv[i][1]);			}		}		// check when the v or h flag are last		if(!(strcmp(argv[argc-1],"-h"))){			h_flag = true;		}		if(!(strcmp(argv[argc-1],"-v"))){			v_flag = true;		}		// checking if h flag to stop and print		if(h_flag){			done = true;		}		// checks that all the required arguments are present		else if(argc < 9 && !done){			puts("./csim: Missing required command line argument");			done = true;		}		// checking that all the flags (for required) were found		if((s_index == -1 || b_index == -1 || e_index == -1 || t_index == -1) && !done){			done = true;			puts("./csim: Missing required command line argument");		}		// proceed with getting the arguments after flags		if (!done) {			char* ptr = 0;			// this gets the set index			long set_index_l = strtol(argv[s_index], &ptr, 10);			set_index = (int) set_index_l;			// this gets the number of lines per set (with v)			long num_lines_l = strtol(argv[e_index], &ptr, 10);			num_lines = (int) num_lines_l;			// this gets the number of block bits (with v)			long block_bits_l = strtol(argv[b_index], &ptr, 10);			block_bits = (int) block_bits_l;			// this checks for all valid input (chars will be zero)			if((set_index <= 0  || num_lines <= 0 || block_bits <= 0) && !done){				done = true;				puts("./csim: Missing required command line argument");			}		}	}	// prints the help if the arguments are not satisfied	if(done == true || h_flag == true) {		printHelp();	}	// all other params are set now time to check the file	strcpy(file_name, argv[t_index]); // get file	fp = fopen(file_name, "r");       // try to open	// if cannot open	if(!fp){		done = true;		printf("%s: No such file or directory\n", argv[t_index]);	}	fclose(fp);	// just to print here to see right now	printf("block bits: %d\n", block_bits);	printf("num_lines: %d\n", num_lines);	printf("set_index: %d\n", set_index);	printf("t_index: %d\n", t_index);	printf("v_flag: %d\n", v_flag);	// this is just for testing purposes right now	fp = fopen(file_name,"r");	char* firstLine = readLine(fp, 0);	printf("\nfirstLine: %s\n", firstLine);  */	// all arguments set before starting        //After testing, change if true to if not done	if (true) {		int hit_count = 0;	//number of hits, initialized to 0		int miss_count = 0;	//number of misses, initialized to 0		int eviction_count = 0;	//number of evictions, initialized to 0		int block_bits = 2;//FOR TESTING PURPOSES ONLY		int set_index = 10;//FOR TESTING PURPOSES ONLY		int num_lines = 4;//FOR TESTING PURPOSES ONLY		int address_size = 32;//FOR TESTING PURPOSES ONLY		int num_sets = 2 ^ set_index;		int block_size = 2 ^ block_bits;	        struct cacheLine * cache;		cache = setCache(num_sets, num_lines, block_size);	//assume function that grabs 1 line of file and determines if it is usable	//the output of that function is the address, called address		int linesInFile = 8;//HARD CODED FOR TESTING, MUST GET CODE FOR THIS		int address = 0x0ffc;//HARD CODED FOR TESTING, MUST REPLACE WITH ACTUAL ADDRESS GRAB CODE	for (int i = 0; i < linesInFile; i++){	  	  int output = cacheLookup(address, cache, set_index, block_bits, address_size, num_lines, i);	   if (output == MISS){//it was a miss, no eviction needed	     miss_count++;	   }	   else if (output == HIT){//it was a hit	     hit_count++;	   }	   else if (output == EVICT){//it was a miss with an eviction	     eviction_count++;	     miss_count++;	   }	   int mult = 0x1000 * i;//TESTING PURPOSES	   address = address + mult;//HARD CODED FOR TESTING, MUST REPLACE WITH ACTUAL ADDRESS GRAB CODE	}	//print verbose code 	printSummary(hit_count, miss_count, eviction_count);	}    return 0;}/** * Gets the index */int getIndex(int address, int index_bits, int offset_bits){  //middle bits are the index  unsigned long index_mask = (1 << index_bits) - 1;//get the correct mask size  index_mask = index_mask << offset_bits;//shift it to the correct location  int index = address & index_mask;//bit manipulation to get index  index = index >> offset_bits;//shift by offset to get actual index  return index;}/** * Gets the tag */int getTag(int address, int tag_bits, int offset_bits, int index_bits){  //front bits are tag  unsigned long tag_mask = (1 << tag_bits) - 1;//get the correct mask size  tag_mask = tag_mask << (offset_bits + index_bits);//shift it to the correct location  int tag = address & tag_mask;//bit manipulation to get tag  return tag;}/** * Sets the valid bit */int setValidBit(struct cacheLine* base_index, int index){  struct cacheLine* location = base_index + index;//set the location to change as the base index plus the given tag plus however many bits are in the tag to get to valid bit  location->validBit = 0;//set the valid bit at that location to the updated value  return 1;}/** * Looks up the given address and determines if it exists in cache */int cacheLookup(int address, struct cacheLine* cache, int index_bits, int block_bits, int address_size, int numLines, int instructNum){  int answer = 0;  int tag_bits = address_size - (index_bits + block_bits);  int tag = getTag(address, tag_bits, block_bits, index_bits);  int index = getIndex(address, index_bits, block_bits);  struct cacheLine* line = cache + (index*numLines);  struct cacheLine* checkLine = cache + (index*numLines);  for (int i = 0; i < numLines; i++){    checkLine = line + i;    int currentTag = checkLine->tag;    int validBit = checkLine->validBit;    if (tag == currentTag && validBit == 1){      answer = 1;    }  }  if (answer == 0){    int passTag = line->tag;    answer = evictionOrMiss(line, passTag, tag, numLines, instructNum);  }  return answer;}/** * Creates the simulated cache */struct cacheLine* setCache(int numSets, int linesPerSet, int blockSize){   struct cacheLine* cacheBasePtr = (struct cacheLine*) malloc((sizeof(struct cacheLine*)*numSets)*linesPerSet);//creates array, cacheSize is pointer to 1st element in array   for (int i = 0; i < numSets; i++){     int index = linesPerSet*i;//casts the line currently on to a cacheLine pointer     setValidBit(cacheBasePtr, index);//initializes the valid bit of each line to 0   }   return cacheBasePtr;     }/** * determines if eviction is needed, performs eviction from cache */int evictionOrMiss(struct cacheLine* line, int currentTag, int tagNext, int numLines, int instructNum){  int eviction = 0;  int validTrue = 0;  struct cacheLine* checkLine = line;  for (int i = 0; i < numLines; i++){//from the structure of the cache, the number of filled lines will all be in order     checkLine = line + i;    int validBit = checkLine->validBit;    if(validBit == 1){      validTrue++;    }  }  if (validTrue == 0){//if none of the lines are filled, populate the first space    line->tag = tagNext;    line->validBit = 1;    line->recentInst = instructNum;  }  else if (validTrue == numLines && numLines == 1){//if all lines are full and it is direct map, populate the space    line->tag = tagNext;    line->validBit = 1;    line->recentInst = instructNum;    eviction = 2;  }  else if(validTrue == numLines && numLines != 1){//if all lines are full and it isn't direct map, determine eviction    struct cacheLine* lruInst = line;    int lruVal = lruInst->recentInst;    int lruNum = 0;    for (int j = 0; j < numLines; j++){      if(lruInst[j].recentInst < lruVal){	lruVal = lruInst[j].recentInst;	lruNum = j;      }    }    line = line + (lruNum - 1);    line->tag = tagNext;    line->validBit = 1;    line->recentInst = instructNum;    eviction = 2;  }  else{//otherwise, put in the next available spot    line = line + validTrue;    line->tag = tagNext;    line->validBit = 1;    line->recentInst = instructNum;  }  return eviction;}